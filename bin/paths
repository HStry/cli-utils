#!/usr/bin/env sh

help_msg="$(cat << EOF
USAGE:
  ${_file} [OPTIONS] [PATH|PATH_ARRAY...]

OPTIONS:
  -h, --help          Show this help message
  -a, --absolute      Make path(s) absolute
  -r, --resolve       Resolve path(s)
  -n, --normalize     Normalize path(s)
  -d, --dedup         Remove duplicate entries from path array
  -p, --purge         Remove non-existing entries from path array
  -s, --sort          Sort entries (alphabetically)
  -x, --split         Split path into its elements
  -X, --split-array   Split paths out of array
  -j, --join          Join path elements into path
  -J, --join-array    Join paths into array

PATH:

PATH_ARRAY:
  If provided, use colon-separated (PATH-style) arrays of paths. If left empty,
  the value of \$PATH will be used.

EXAMPLES:
  Prepend userhome bin directory to PATH, resolve symlinks, and filter out
  duplicate entries.
  \$ ${_file} -Jdr "${USER}/.local/bin" "${PATH}"

EOF
)"

path_absolute() (
  # TODO
)

path_normalize() (
  # TODO
)

path_resolve() (
  # TODO
)

path_relative_to() (
  # TODO
)

path_split() (
  # TODO
)

paths_common() (
  dups() (
    for s in "$@"; do echo "${s}"; done | sort | uniq -d
  )
  findrel() (
    d="$(realpath "${1}")"
    find "${d}" \
    | while IFS= read line; do
        [ "${line#${d}}" = "${line}" ] && echo "Something went wrong with '${line}'" >&2
        printf '+/%s\n' "$(echo "${line#${d}}" | sed 's/^\///')"
      done
  )
  objects_common=''
  for d in "$@"; do
    if ! [ -d "${d}" ]; then
      echo "Object '${d}' is not a directory - skipping." >&2
      continue
    fi
    objects="$(findrel "${d}")"
    [ -z "${objects_common}" ] && objects_common="${objects}" && continue
    objects_common="$(dups "${objects_common}" "${objects}")"
  done
  echo "${objects_common}"
)

path_join() (
  [ "${1}" = '/' ] && echo -n '/' && shift
  for p in "$@"; do
    echo "${p}" \
    | while IFS= read el; do
      el="$(echo "${el}" \
            | sed -e 's/^\s*\(\/\+\s*\)\?//' \
                  -e 's/\(\/\+\s*\)\?\s*$//')"
      [ -n "${el}" ] && echo -n "\/${el}"
    done
  done \
  | sed -e 's/^\///'
)

path_array_split() (
  path_array="$(echo "${1}" \
                | sed -e "s/\\\\\\\\/${ebs}/g" \
                      -e "s/\\\\:/${ecn}/g" \
                      -e "s/\\\'/${esq}/g" \
                      -e "s/\\\\\"/${edq}/g")"
  _path_array=''
  while [ "${path_array}" != "${_path_array}" ]; do
    _path_array="${path_array}"
    path_array="$(echo "${path_array}" \
                  | sed -e "s/'\([^\']*\):\([^\']*\)'/'\1${icn}\2'/g" \
                        -e "s/\"\([^\"]*\):\([^\"]*\)\"/\"\1${icn}\2\"/g")"
  done
  echo "${path_array}" \
  | sed -e 's/:/\n/g' \
        -e "s/${icn}/:/g" \
        -e "s/${edq}/\\\\\"/g" \
        -e "s/${esq}/\\\'/g" \
        -e "s/${ecn}/\\\\:/g" \
        -e "s/${ebs}/\\\\\\\\/g"
)

path_array_join() (
  for p in "$@"; do
    echo "${p}" \
    | while IFS= read el; do
      el="$(echo "${el}" \
            | sed -e 's/^\s*\(:\+\s*\)\?//' \
                  -e 's/\(:\+\s*\)\?\s*$//')"
      [ -n "${el}" ] && echo -n ":${el}"
    done
  done \
  | sed -e 's/^://'
)

set_placeholders() {
  ebs="$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | head -c 16)"
  ecn="$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | head -c 16)"
  esq="$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | head -c 16)"
  edq="$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | head -c 16)"
  icn="$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | head -c 16)"
}

set_identity() {
  _self="$(path_absolute "${1}")"
  _path="${_self%/*}"
  _file="${_self##*/}"
  _name="${_file%.*}"
}

parse_args() {
  # TODO
}

main() (
  # TODO
)

set_identity "$0" || exit $?
set_placeholders || exit $?
parse_args "$@" || exit $?
main || exit $?
