#!/usr/bin/env sh

# Yes, this all can be solved by a simple 'sed -z', were it not for
# that fucking piece of shit busybox with its plethora of non-standard
# command implementations, like sed, realpath, etc.
# I mean, seriously, JFC, what the actual f*!

help_msg="$(cat << EOF
wscleaner - clean whitespace from text files.

USAGE:
  wscleaner [OPTIONS] [--] FILE [FILE...]

OPTIONS:
  -h, --help                    Show this help text
  -t, --trailing                Remove trailing whitespace
  -H, --head                    Remove empty lines from the top
  -T, --tail                    Remove empty lines on the bottom
  -c, --consecutive [N]         Remove consecutive empty lines over N(=1)
  -W, --ws-not-empty            Whitespace (spaces, tabs) are content
  -i, --inplace                 Edit file(s) in place
  -o, --output FILE [FILE...]   Output to FILE [FILE...]
EOF
)"

help=0
trailing=0
head=0
tail=0
whitespace_is_empty=1
inplace=0
consecutive=1
output=''
input=''

parse_args=1
active_arg=''

for arg in "$@"; do
  [ ${parse_args} -gt 0 ] && [ "${arg}" = '--' ] && active_arg='' && parse_args=0 && continue
  [ ${parse_args} -le 0 ] && [ "${arg}" = '++' ] && parse_args=1 && continue
  if [ ${parse_args} -gt 0 ] && [ "${arg#--}" != "${arg}" ]; then
    case "${arg#--}" in
      'help')         help=1;                 ; continue;;
      'trailing')     trailing=1              ; continue;;
      'head')         head=1                  ; continue;;
      'tail')         tail=1                  ; continue;;
      'ws-not-empty') whitespace_is_empty=0   ; continue;;
      'inplace')      inplace=1               ; continue;;
      'consecutive')  active_arg='consecutive'; continue;;
      'output')       active_arg='output'     ; continue;;
      *) echo "Command-line option '${arg}' not recognized." >&2;
         exit 255;;
    esac
  elif [ ${parse_args} -gt 0 ] && [ "${arg#-}" != "${arg}" ]; then
    for i in $(seq 2 ${#arg}); do
      a="$(echo "${arg}" | head -c ${i} | tail -c 1)"
      case "${arg#--}" in
        'h'|'?') help=1;                 ; continue;;
        't')     trailing=1              ; continue;;
        'H')     head=1                  ; continue;;
        'T')     tail=1                  ; continue;;
        'W')     whitespace_is_empty=0   ; continue;;
        'i')     inplace=1               ; continue;;
        'c')     active_arg='consecutive'; continue;;
        'o')     active_arg='output'     ; continue;;
        *) echo "Command-line option '-${a}' not recognized." >&2;
           exit 255;;
      esac
    done
  fi
  if [ "${active_arg}" = 'consecutive' ]; then
    if echo "${arg}" | grep -q '^-[0-9]\+$'; then
      echo "Positive numeric value required for 'consecutive' option." >&2
      exit 255
    elif ! echo "${arg}" | grep -q '^\(0\|[1-9][0-9]*\)$'; then
      echo "Numeric value required for 'consecutive' option." >&2
      exit 255
    fi
    consecutive=${arg}
    active_arg=''
  elif [ "${active_arg}" = 'output' ]; then
    output="$(echo "${output}"; echo "${arg}")"
  elif [ "${active_arg}" = '' ]; then
    input="$(echo "${input}"; echo "${arg}")"
  else
    echo "Coding error; unhandled active arg case '${active_arg}'" >&2
    exit 255
  fi
done

[ ${help} -gt 0 ] && echo "${help_msg}" >&2 && exit 0
if [ ${inplace} -gt 0 ] && [ ${#output} -gt 0 ]; then
  echo "Cannot provide 'inplace' option together with 'output'." >&2
  exit 255
elif [ ${#output} -gt 0 ] && [ $(echo "${input}" | wc -l) -ne $(echo "${output}" | wc -l) ]; then


_get_str() (
  [ $# -le 0 ] && echo "Missing required STR argument." >&2 && exit 255
  [ $# -gt 1 ] && echo "Too many arguments provided." >&2 && exit 255
  [ -f "${1}" ] && cat "${1}" || echo "${1}"
)

_line_is_empty() (
  [ ${whitespace_is_empty:-1} -gt 0 ] && ptn='^\s*$' || ptn='^$'
  echo "${1}" | grep -q "${ptn}"
)

strip_trailing_whitespace() (
  s="$(_get_str "$@")" || exit $?
  echo "${s}" | sed -e 's/\s*$//'
)

strip_leading_empty_lines() (
  s="$(_get_str "$@")" || exit $?
  head=1
  echo "${s}" \
  | while IFS= read line; do
    if [ ${head} -gt 0 ]; then
      _line_is_empty "${line}" && continue
      head=0
    fi
    echo "${line}"
  done
)

strip_trailing_empty_lines() (
  s="$(_get_str "$@")" || exit $?
  strip_leading_empty_lines "$(echo "${s}" | tac)" | tac
)

strip_repeating_empty_lines() (
  s="$(_get_str "$@")" || exit $?
  allowed_empty_line_count="${ALLOWED_EMPTY_LINE_COUNT:-1}"
  empty_line_count=0
  echo "${s}" \
  | while IFS= read line; do
    echo "${line}" | grep -q '^\s*$' \
      && empty_line_count=$(( ${empty_line_count} + 1 )) \
      || empty_line_count=0
    [ ${empty_line_count} -le ${allowed_empty_line_count} ] && echo "${line}"
  done
)
